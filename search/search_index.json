{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Sindri began as a tool specifically for managing a modded Valheim server in a container. As such, it's name originated from Norse mythology.</p> <p>Since then, it has grown into a more generalized form as a toolkit for turning Steamapp servers into container images--modded or otherwise. Sindri evolved this way because every open source container images I've came across for Steamapp servers is bloated with all kinds of additional, unnecessary software with their own nuances to tease out and I am tired of building and pushing my own container images. While it still boasts a tool that is an especially helpful wrapper around the Valheim server, it also includes other tools to support efforts building minimal container images for any Steamapp servers.</p> <p>These tools include:</p> <ul> <li><code>boiler</code>, a container image for a read-only container registry for pulling images with Steamapps pre-installed on them, built on-demand.</li> <li><code>valheimw</code>, a container image containing a wrapper around the Valheim server that manages its mods via thunderstore.io and runs an HTTP server alongside it to provide additional functionality.</li> <li><code>mist</code>, a CLI tool for use in <code>Dockerfile</code>s to install Steamapps, Steam Workshop items, and thunderstore.io mods.</li> </ul>"},{"location":"boiler/","title":"Boiler","text":"<p><code>boiler</code> is Sindri's crown jewel. Inspired by Nixery, it is a read-only container registry for pulling images with Steamapps pre-installed on them. The base of the images is <code>debian:stable-slim</code>. Images are non-root and <code>steamcmd</code> is never installed on them, so there's no leftover files from it on the image's filesystem or in its layers. Images are built on-demand rather than being stored, waiting to be pulled.</p> <p>The image's name refers to a Steamapp ID. Check out SteamDB to find your desired Steamapp ID if you do not already know it.</p> <p>The image's tag maps to the Steamapp's branch, except the specific case of the default tag \"latest\" which maps to the default Steamapp branch \"public\".</p> <p>Layers and manifests are cached after being pulled via tag so that subsequent pulls via digest will function and be snappy. Subsequent pulls via tag will cause <code>boiler</code> to rebuild the container image to check if a new build has been released on the given branch. Such pulls are still faster than the first, especially if a new build has not been released because no cacheing would need to be done.</p> <p>Steamapps sometimes have entrypoints that are non-configurable without editing files that they provide and frequently have additional system dependencies that need to be installed. This makes them incompatible with regular container patterns such as using environment variables or arguments to modify the functionality of the container. To work around this, <code>boiler</code> uses a hardcoded database to automatically fix the container images of some Steamapps before returning the images to the puller by installing dependencies, moving files around, and modifying the entrypoint.</p> <p>Although I am open to the idea, there is currently no public instance of <code>boiler</code>. I would like one to exist with a non-hardcoded, community-maintainable database to automatically fix the container images of all Steamapps whose out-of-the-box configuration is lacking. Until then, you must run your own. Thankfully, doing so is easy.</p> <p>Taking the Valheim server as an example of how <code>boiler</code> could be used, consider a directory with the following <code>docker-compose.yml</code>:</p> <pre><code>services:\n  buildkitd:\n    image: moby/buildkit:rootless\n    security_opt:\n      - seccomp=unconfined\n      - apparmor=unconfined\n    command:\n      - --addr\n      - --buildkitd=tcp://0.0.0.0:1234\n      - --oci-worker-no-process-sandbox\n  boiler:\n    image: ghcr.io/frantjc/boiler\n    command:\n      - tcp://buildkitd:1234\n    ports:\n      - 5000:5000\n    depends_on:\n      - buildkitd\n  valheim:\n    image: localhost:5000/896660\n    command:\n      - -name\n      - My server\n      - -world\n      - Dedicated\n      - -password\n      - secret\n      - -crossplay\n    ports:\n      - 2456:2456/udp\n    depends_on:\n      - boiler\n</code></pre> <p>The Valheim server is one of a few Steamapps that is included in the hardcoded database, so it works out of the box.</p> <p>\"896660\" refers to the Steamapp ID of the Valheim server.</p> <p>First, run <code>boiler</code> in the background. We will use it to pre-build a container image with the Valheim server installed:</p> <pre><code>docker compose up --detach boiler\n</code></pre> <p>Next, build and run the Valheim server. This will pull a minimal container image with it pre-installed from <code>boiler</code> and then run the Valheim server container:</p> <pre><code>docker compose up --detach valheim\n</code></pre> <p>When this command is ran, <code>docker</code> will pull the Valheim server container image by making a series of HTTP requests to the <code>boiler</code> instance ran in the previous step. To satisfy those HTTP requests, <code>boiler</code> will build and cache the various manifests and blobs of the container image. As a result, the pull can take some time, especially on the first run when <code>boiler</code> has not cached the layers. After the pull is complete, the Valheim server will run.</p>"},{"location":"corekeeper/","title":"Core Keeper","text":"<p>Consider a directory with the following <code>docker-compose.yml</code>:</p> <pre><code>services:\n  buildkitd:\n    image: moby/buildkit:rootless\n    security_opt:\n      - seccomp=unconfined\n      - apparmor=unconfined\n    command:\n      - --addr\n      - tcp://0.0.0.0:1234\n      - --oci-worker-no-process-sandbox\n  boiler:\n    image: ghcr.io/frantjc/boiler\n    command:\n      - --buildkitd=tcp://buildkitd:1234\n    ports:\n      - 5000:5000\n    depends_on:\n      - buildkitd\n  corekeeper:\n    image: localhost:5000/1963720\n    volumes:\n      - ./saves:/home/steam/.config/unity3d/Pugstorm/Core Keeper/DedicatedServer\n    depends_on:\n      - boiler\n</code></pre> <p>The Core Keeper server is one of a few Steamapps that is included in the hardcoded database, so it works out of the box.</p> <p>\"1963720\" refers to the Steamapp ID of the Core Keeper server.</p> <p>This <code>docker-compose.yml</code> runs the Core Keeper server. To use it, place it in a directory and run the following command there:</p> <pre><code>docker compose up --detach boiler\n</code></pre> <p>Next, build and run the Core Keeper server. This will pull a minimal container image with it pre-installed from <code>boiler</code> and then run the Core Keeper server container:</p> <pre><code>docker compose up --detach corekeeper\n</code></pre> <p>If Core Keeper errors with <code>Segmentation fault (core dumped)</code>, you have likely ran into a permissions issue. Run <code>chmod -R 777 ./save</code> and try again.</p> <p>The server's save data will be stored in <code>./saves</code>.</p> <p>Notably, the Core Keeper server does not any ports exposed, instead using magic to allow players to connect to the server.</p> <p>Once the container finishes starting up, the game ID will be in its logs and can be used to connect to the server.</p>"},{"location":"developing/","title":"Developing","text":""},{"location":"developing/#prerequisites","title":"Prerequisites","text":"<p><code>go</code> 1.24, <code>docker</code>, <code>node</code> 20, <code>kubectl</code> and a Kubernetes cluster.</p>"},{"location":"developing/#running-locally","title":"Running locally","text":"<p>The first time you're running against a cluster or any time you change the types of a CRD, run:</p> <pre><code>make apply\n</code></pre> <p>Now you can the backend services against your cluster:</p> <pre><code>docker compose up --build stoker boiler migrate\n</code></pre> <p>The migrate service just initializes the cluster with some well-known Steamapps</p> <p>If you're developing the frontend, you can bring it up with hot-reloading, too:</p> <pre><code>yarn\nSTOKER_URL=http://localhost:5050/ yarn dev\n</code></pre>"},{"location":"developing/#components","title":"Components","text":""},{"location":"developing/#boiler","title":"Boiler","text":"<p>A read-only container registry that builds the requested Steamapp container image on-demand and caches it for later. Boiler \"contains Steam\".</p>"},{"location":"developing/#stoker","title":"Stoker","text":"<p>An API that handles CRUD for our Steamapp data model which contains the extra information necessary for Boiler to understand how to build a Steamapp's container image. Stoker \"fuels Boiler\".</p>"},{"location":"developing/#glossary","title":"Glossary","text":""},{"location":"developing/#read-only-container-registry","title":"Read-only container registry","text":"<p>An HTTP(S) REST API from which you can <code>docker pull</code>, but not <code>docker push</code></p>"},{"location":"developing/#kubernetes-resource","title":"Kubernetes resource","text":"<p>A piece of data, generally represented as YAML, which can be passed to <code>kubectl apply -f</code> to send as a request to a Kubernetes' cluster's kube-apiserver. Such objects contain the desired and actual state of the thing that they represent, the two of which can be out of sync, but are always being brought closer together. Some common, builtin examples are Pods and ConfigMaps.</p>"},{"location":"developing/#custom-resource-definition-crd","title":"Custom Resource Definition (CRD)","text":"<p>A Kubernetes resource which defines a new, custom kind of Kubernetes resource.</p>"},{"location":"developing/#custom-resource-cr","title":"Custom Resource (CR)","text":"<p>An instance of a CRD.</p>"},{"location":"developing/#kubernetes-controller","title":"Kubernetes controller","text":"<p>A service which connects to a Kubernetes cluster via its kube-apiserver, watches for events relating to a resource, and reacts to them to bring the desired and actual state of the thing that they represent closer together.</p> <p>Synonomous with Kubernetes operator.</p>"},{"location":"developing/#steamapp","title":"Steamapp","text":"<p>A collection of files that can be downloaded from Steam via <code>steamcmd +app_update</code> and which has metadata retrievable from <code>steamcmd +app_info_print</code> that contains information about how to execute its entrypoint.</p> <p>Often, said metadata contains insufficient information about how to execute the Steamapp's entrypoint, such as which system dependencies are necessary. To make up for this shortcoming, this term also refers to Sindri's data model which represents the extra information necessary to understand how to execute its files' entrypoint as well as the CRD that said data model is stored as.</p>"},{"location":"developing/#repository-structure","title":"Repository structure","text":"<p>Sindri consists of two distinct technology stacks, both hosted at the root of the repository. The first is a Go module focused on tooling for building container images for Steamapps. The second is a Remix application that acts as a frontend to one of the services built from the Go module.</p> <p>Like many of my projects, Sindri observes gocloud.dev's URL concept to inform a great deal of the code organization. That is, a package may declare an <code>interface</code> and even a <code>urlMux</code>. Subpackages then should be created to implement that <code>interface</code> one way and that subpackage may register its implementation in the parent's <code>urlMux</code>. For instance, <code>github.com/frantjc/sindri/steamworkshopitem</code> is entirely dedicated to implemening <code>github.com/frantjc/sindri.URLOpener</code>.</p> <p>New packages in Sindri may also indicate a new logical grouping of code. For instance, <code>github.com/frantjc/sindri/contreg</code> is exclusively dedicated to defining the HTTP portion of a read-only container registry.</p>"},{"location":"mist/","title":"Mist","text":"<p><code>mist</code> is a CLI tool for use in <code>Dockerfile</code>s to install Steamapps, Steam Workshop items, and thunderstore.io mods. It uses GoCloud's URL concept to expose installing the content from the different sources using a similar command.</p> <p>The following <code>Dockerfile</code> builds a container image for a modded Valheim server and provides an excellent example for how to use <code>mist</code>:</p> <pre><code>FROM debian:stable-slim\nCOPY --from=ghcr.io/frantjc/mist /mist /usr/local/bin\nRUN apt-get update -y \\\n    &amp;&amp; apt-get install -y --no-install-recommends \\\n        # So that mist can make a trusted TLS connection\n        # to download `steamcmd`.\n        ca-certificates \\\n        # `mist` installs `steamcmd`, but we still have to\n        # satisfy `steamcmd`'s dependencies.\n        lib32gcc-s1 \\\n    &amp;&amp; apt-get clean \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/* \\\n    # Install the Valheim server to /root/valheim.\n    # \"896660\" refers to the Steamapp ID of the Valheim server.\n    &amp;&amp; mist steamapp://896660 /root/valheim \\\n    # Install BepInEx to /root/valheim.\n    &amp;&amp; mist thunderstore://denikson/BepInExPack_Valheim /root/valheim \\\n    # Install EquipmentAndQuickSlots to /root/valheim/BepInEx/plugins.\n    &amp;&amp; mist thunderstore://RandyKnapp/EquipmentAndQuickSlots /root/valheim/BepInEx/plugins \\\n    # Cleanup.\n    &amp;&amp; mist --clean \\\n    &amp;&amp; rm /usr/local/bin/mist \\\n    &amp;&amp; apt-get remove -y \\\n        ca-certificates \\\n        lib32gcc-s1\nWORKDIR /root/valheim/\nENTRYPOINT [\"/root/valheim/start_server.sh\"]\n</code></pre>"},{"location":"palworld/","title":"Palworld","text":"<p>Consider a directory with the following <code>docker-compose.yml</code>:</p> <pre><code>services:\n  buildkitd:\n    image: moby/buildkit:rootless\n    security_opt:\n      - seccomp=unconfined\n      - apparmor=unconfined\n    command:\n      - --addr\n      - tcp://0.0.0.0:1234\n      - --oci-worker-no-process-sandbox\n  boiler:\n    image: ghcr.io/frantjc/boiler\n    command:\n      - --buildkitd=tcp://buildkitd:1234\n    ports:\n      - 5000:5000\n    depends_on:\n      - buildkitd\n  palworld:\n    image: localhost:5000/2394010\n    ports:\n      - 8211:8211/udp\n    depends_on:\n      - boiler\n</code></pre> <p>The Palworld server is one of a few Steamapps that is included in the hardcoded database, so it works out of the box.</p> <p>\"2394010\" refers to the Steamapp ID of the Palworld server.</p> <p>To run the Palworld server this way, run the following commands in the directory that the above files are placed in.</p> <p>First, run <code>boiler</code> in the background. We will use it to pre-build a container image with the Palworld server installed:</p> <pre><code>docker compose up --detach boiler\n</code></pre> <p>Next, build and run the Palworld server. This will pull a minimal container image with it pre-installed from <code>boiler</code> and then run the Palworld server container:</p> <pre><code>docker compose up --detach palworld\n</code></pre> <p>Finally, <code>boiler</code> can be stopped:</p> <pre><code>docker compose down boiler\n</code></pre>"},{"location":"valheim/","title":"Valheim","text":"<p>Sindri boasts special support for Valheim among other Steamapp servers due to its origins.</p>"},{"location":"valheim/#valheimw","title":"<code>valheimw</code>","text":"<p>This special supports comes in the form of <code>valheimw</code>, a Valheim server wrapper. Instead of being a Steamapp server that Sindri can help build into a container image, <code>valheimw</code> is a pre-built tool specifically for Valheim servers, modded or otherwise. If mods are specified, it uses BepInEx to load them.</p> <p>It provides additional features beyond that in an HTTP server that it runs alongside the Valheim server, including:</p> <ul> <li>Download a tarball of the mods in use to distribute them to other players.</li> <li>Download the world's <code>.db</code> and <code>.fwl</code> files.</li> <li>Get information from the world's <code>.fwl</code> file, parsed on your behalf.</li> <li>Go to the world's valheim-map.world page.</li> </ul> <p>For an example of how to use <code>valheimw</code>, consider a directory with the following <code>docker-compose.yml</code>:</p> <pre><code>services:\n  valheimw:\n    image: ghcr.io/frantjc/valheimw\n    command:\n      # The name of the Valheim server's save files.\n      # If they already exist, it will load them. If\n      # they do not, it will create them.\n      # Optional. Default \"sindri\".\n      # - --world=hello\n      # The name of the Valheim server as a player would\n      # see it in-game when connecting to it.\n      # Optional. Default \"sindri\".\n      # - --name=there\n      # Can be specified if you want to run a\n      # pre-release version of the Valheim server.\n      # Optional.\n      # - --beta=public-test\n      # - --beta-password=yesimadebackups\n      # Browse https://valheim.thunderstore.io/ for available mods.\n      # Names are case-sensitive.\n      # Optional.\n      # - --mod=RandyKnapp/EquipmentAndQuickSlots\n    environment:\n      # The password you will use to connect to your server.\n      # Required. Must be at least 5 characters, and cannot\n      # be contained within your world name. Default world name\n      # is \"sindri\".\n      VALHEIM_PASSWORD: hellothere\n    volumes:\n      # `valheimw` caches stuff here and the Valheim server's\n      # save data is here by default.\n      - ./saves:/home/valheimw/.cache\n    ports:\n      # Expose the Valheim server's port.\n      # If you change the Valheim server's port from its default,\n      # via `--port`, ensure that this is changed to match.\n      - 2456:2456/udp\n      # Expose `valheimw`'s HTTP server's port.\n      # If you change `valheimw`'s HTTP server's port from its default,\n      # via `--addr`, ensure that this is changed to match.\n      - 8080:8080\n</code></pre> <p>To run the <code>valheimw</code> this way, run the following command in the directory that the above file is placed in.</p> <pre><code>docker compose up\n</code></pre> <p>Once <code>valheimw</code> is running, its helpful HTTP server can be used.</p> <p>To get the world's seed, run the following:</p> <pre><code>curl http://localhost:8080/seed.txt\n</code></pre> <p>To go to the world's valheim-map.world page, open localhost:8080/map.</p> <p>To download the mods that the Valheim server is using (if any), run the following command:</p> <pre><code>curl http://localhost:8080/mods.gz | tar -xzf-\n</code></pre> <p>To see an exhaustive list of arguments for <code>valheimw</code>, see the following or run the help command yourself:</p> <pre><code>docker run ghcr.io/frantjc/valheimw --help\n</code></pre> <pre><code>Usage:\n  valheimw [flags]\n\nFlags:\n      --addr string              address (default \":8080\")\n      --admin int64Slice         Valheim server admin Steam IDs (default [])\n      --backup-long duration     Valheim server -backuplong duration\n      --backup-short duration    Valheim server -backupshort duration\n      --backups int              Valheim server -backup amount\n      --ban int64Slice           Valheim server banned Steam IDs (default [])\n      --beta string              Steam beta branch\n      --beta-password string     Steam beta password\n      --combat-modifier          Valheim server -modifier combat\n      --crossplay                Valheim server enable -crossplay\n      --death-penalty-modifier   Valheim server -modifier deathpenalty\n  -h, --help                     help for valheimw\n      --instance-id string       Valheim server -instanceid\n  -m, --mod stringArray          Thunderstore mods (case-sensitive)\n      --name string              Valheim server -name (default \"sindri\")\n      --no-build-cost            Valheim server -setkey nobuildcost\n      --no-db                    do not expose the world .db file for download\n      --no-fwl                   do not expose the world .fwl file information\n      --no-map                   Valheim server -setkey nomap\n      --passive-mobs             Valheim server -setkey passivemobs\n      --permit int64Slice        Valheim server permitted Steam IDs (default [])\n      --player-events            Valheim server -setkey playerevents\n      --port int                 Valheim server -port (0 to use default)\n      --portal-modifier          Valheim server -modifier portals\n      --preset                   Valheim server -preset\n      --public                   Valheim server make -public\n      --raid-modifier            Valheim server -modifier raids\n      --resource-modifier        Valheim server -modifier resources\n      --save-interval duration   Valheim server -saveinterval duration\n      --savedir string           Valheim server -savedir (default \"/home/valheimw/.cache/sindri/valheim\")\n  -V, --verbose count            verbosity\n  -v, --version                  version for valheimw\n      --world string             Valheim server -world (default \"sindri\")\n</code></pre>"},{"location":"valheim/#if-you-dont-want-to-use-valheimw","title":"If you don't want to use <code>valheimw</code>...","text":"<p><code>boiler</code> is able to help.</p>"}]}